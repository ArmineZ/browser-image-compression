{"version":3,"file":"browser-image-compression.js","sources":["../lib/utils.js","../lib/image-compression.js","../lib/web-worker.js","../lib/index.js"],"sourcesContent":["/**\n * getDataUrlFromFile\n *\n * @param {File} file\n * @returns {Promise<string>}\n */\nexport function getDataUrlFromFile (file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.readAsDataURL(file)\n    reader.onload = () => {\n      resolve(reader.result)\n    }\n    reader.onerror = reject\n  })\n}\n\n/**\n * getFilefromDataUrl\n *\n * @param {string} dataurl\n * @param {string} filename\n * @param {number} lastModified\n * @returns {Promise<File|Blob>}\n */\nexport function getFilefromDataUrl (dataurl, filename, lastModified = Date.now()) {\n  return new Promise((resolve) => {\n    const arr = dataurl.split(',')\n    const mime = arr[0].match(/:(.*?);/)[1]\n    const bstr = atob(arr[1])\n    let n = bstr.length\n    const u8arr = new Uint8Array(n)\n    while (n--) {\n      u8arr[n] = bstr.charCodeAt(n)\n    }\n    let file\n    try {\n      file = new File([u8arr], filename, { type: mime }) // Edge do not support File constructor\n    } catch (e) {\n      file = new Blob([u8arr], { type: mime })\n      file.name = filename\n      file.lastModified = lastModified\n    }\n    resolve(file)\n  })\n}\n\n/**\n * loadImage\n *\n * @param {string} src\n * @returns {Promise<HTMLImageElement>}\n */\nexport function loadImage (src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = () => {\n      resolve(img)\n    }\n    img.onerror = reject\n    img.src = src\n  })\n}\n\n/**\n * drawImageInCanvas\n *\n * @param {HTMLImageElement} img\n * @param {string} [maxWidthOrHeight]\n * @returns {HTMLCanvasElement}\n */\nexport function drawImageInCanvas (img, maxWidthOrHeight) {\n  let canvas\n  if (typeof OffscreenCanvas === 'function') {\n    canvas = new OffscreenCanvas(img.width, img.height)\n  } else {\n    canvas = document.createElement('canvas')\n  }\n  const ctx = canvas.getContext('2d')\n\n  if (Number.isInteger(maxWidthOrHeight) && (img.width > maxWidthOrHeight || img.height > maxWidthOrHeight)) {\n    if (img.width > img.height) {\n      canvas.width = maxWidthOrHeight\n      canvas.height = (img.height / img.width) * maxWidthOrHeight\n    } else {\n      canvas.width = (img.width / img.height) * maxWidthOrHeight\n      canvas.height = maxWidthOrHeight\n    }\n  } else {\n    canvas.width = img.width\n    canvas.height = img.height\n  }\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n  return canvas\n}\n\nexport async function drawFileInCanvas (file, maxWidthOrHeight) {\n  let img\n  try {\n    img = await createImageBitmap(file)\n  } catch (e) {\n    const dataUrl = await getDataUrlFromFile(file)\n    img = await loadImage(dataUrl)\n  }\n  const canvas = drawImageInCanvas(img, maxWidthOrHeight)\n  return [img, canvas]\n}\n\nexport async function canvasToFile (canvas, fileType, fileName, fileLastModified, quality = 1) {\n  let compressedFile\n  if (canvas instanceof OffscreenCanvas) {\n    compressedFile = await canvas.convertToBlob({ type: fileType, quality })\n    compressedFile.name = fileName\n    compressedFile.lastModified = fileLastModified\n  } else {\n    const dataUrl = canvas.toDataURL(fileType, quality)\n    compressedFile = await getFilefromDataUrl(dataUrl, fileName, fileLastModified)\n  }\n  return compressedFile\n}","import { drawFileInCanvas, canvasToFile } from './utils'\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight }\n * @returns {Promise<File>}\n */\nexport default async function compress (file, options) {\n  let remainingTrials = options.remainingTrials || 10\n\n  const maxSizeByte = options.maxSizeMB * 1024 * 1024\n\n  const temp = await drawFileInCanvas(file, options.maxWidthOrHeight)\n  const img = temp[0]\n  const canvas = temp[1]\n\n  let quality = 1\n  let compressedFile = await canvasToFile(canvas, file.type, file.name, file.lastModified, quality)\n  if (file.type === 'image/png') {\n    while (remainingTrials-- && compressedFile.size > maxSizeByte) {\n      canvas.width *= 0.9\n      canvas.height *= 0.9\n\n      const ctx = canvas.getContext('2d')\n      ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n      compressedFile = await canvasToFile(canvas, file.type, file.name, file.lastModified, quality)\n    }\n  } else { // if (file.type === 'image/jpeg') {\n    while (remainingTrials-- && compressedFile.size > maxSizeByte) {\n      canvas.width *= 0.9\n      canvas.height *= 0.9\n\n      const ctx = canvas.getContext('2d')\n      ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n      quality *= 0.9\n      compressedFile = await canvasToFile(canvas, file.type, file.name, file.lastModified, quality)\n    }\n  }\n\n  return compressedFile\n}","import imageCompression from './index'\nimport compress from './image-compression'\n\nlet cnt = 0\nlet imageCompressionLibUrl\n\nfunction createWorker (f) {\n  return new Worker(URL.createObjectURL(new Blob([`(${f})()`])))\n}\n\nconst worker = createWorker(() => {\n  self.addEventListener('message', async (e) => {\n    const { file, id, imageCompressionLibUrl, options } = e.data\n    try {\n      console.log('[worker] importScripts', imageCompressionLibUrl)\n      importScripts(imageCompressionLibUrl)\n      console.log('[worker] self', self)\n      const compressedFile = await imageCompression(file, options)\n      self.postMessage({ file: compressedFile, id })\n    } catch (e) {\n      console.error('[worker] error', e)\n      self.postMessage({ error: e.message, id })\n    }\n  })\n})\n\nfunction createSourceObject (str) {\n  return URL.createObjectURL(new Blob([str], { type: 'application/javascript' }))\n}\n\nexport function compressOnWebWorker (file, options) {\n  return new Promise(async (resolve, reject) => {\n    if (!imageCompressionLibUrl) {\n      imageCompressionLibUrl = createSourceObject(`\n    function imageCompression (){return (${imageCompression}).apply(null, arguments)}\n    imageCompression.drawImageInCanvas = ${imageCompression.drawImageInCanvas}\n    imageCompression.getDataUrlFromFile = ${imageCompression.getDataUrlFromFile}\n    imageCompression.getFilefromDataUrl = ${imageCompression.getFilefromDataUrl}\n    imageCompression.loadImage = ${imageCompression.loadImage}\n    imageCompression.drawFileInCanvas = ${imageCompression.drawFileInCanvas}\n    imageCompression.canvasToFile = ${imageCompression.canvasToFile}\n    drawImageInCanvas = imageCompression.drawImageInCanvas\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\n    loadImage = imageCompression.loadImage\n    drawFileInCanvas = imageCompression.drawFileInCanvas\n    canvasToFile = imageCompression.canvasToFile\n    function compress (){return (${compress}).apply(null, arguments)}\n    `)\n      // imageCompressionLibUrl = new URL('../dist/browser-image-compression.js', window.location.href).href\n    }\n    let id = cnt++\n\n    function handler (e) {\n      if (e.data.id === id) {\n        worker.removeEventListener('message', handler)\n        if (e.data.error) {\n          reject(e.data.error)\n        }\n        resolve(e.data.file)\n      }\n    }\n\n    worker.addEventListener('message', handler)\n    worker.postMessage({ file, id, imageCompressionLibUrl, options })\n  })\n}","import compress from './image-compression'\nimport {\n  canvasToFile,\n  drawFileInCanvas,\n  drawImageInCanvas,\n  getDataUrlFromFile,\n  getFilefromDataUrl,\n  loadImage\n} from './utils.js'\nimport { compressOnWebWorker } from './web-worker'\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=true }\n * @returns {Promise<File>}\n */\nasync function imageCompression (file, options) {\n\n  options.maxSizeMB = options.maxSizeMB || Number.POSITIVE_INFINITY\n  options.useWebWorker = typeof options.useWebWorker === 'boolean' ? options.useWebWorker : true\n\n  if (!(file instanceof Blob || file instanceof File)) {\n    throw new Error('The file given is not an instance of Blob or File')\n  } else if (!/^image/.test(file.type)) {\n    throw new Error('The file given is not an image')\n  }\n\n  // try run in web worker, fall back to run in main thread\n  const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n  if (options.useWebWorker && typeof Worker === 'function' && !inWebWorker) {\n    try {\n      const compressedFile = await compressOnWebWorker(file, options)\n      compressedFile.name = file.name\n      compressedFile.lastModified = file.lastModified\n      return compressedFile\n    } catch (e) {\n      console.error('run compression in web worker failed', e)\n    }\n  }\n  if (inWebWorker) {\n    console.log('run compression in web worker')\n  } else {\n    console.log('run compression in main thread')\n  }\n\n  const compressedFile = await compress(file, options)\n  compressedFile.name = file.name\n  compressedFile.lastModified = file.lastModified\n  return compressedFile\n}\n\nimageCompression.drawImageInCanvas = drawImageInCanvas\nimageCompression.getDataUrlFromFile = getDataUrlFromFile\nimageCompression.getFilefromDataUrl = getFilefromDataUrl\nimageCompression.loadImage = loadImage\nimageCompression.canvasToFile = canvasToFile\nimageCompression.drawFileInCanvas = drawFileInCanvas\n\nexport default imageCompression\n"],"names":["resolve","Promise","dataurl","split","bstr","length","filename","Blob","file","loadImage","img","Image","onload","reject","canvas","OffscreenCanvas","cnt","message","imageCompression","e","data"],"mappings":"iQAaIA,4MAyBE,IAAAC,gCACAC,EAAAC,qDACAC,EAAKC,wEAaqBC,wBAE5B,IAAAC,yBACAD,qBAGIE,cAiBJC,kDAEIC,EAAM,IAAAC,MAEZD,EAAAE,OAAA,2BAGIC,6KAsBI,yNAHNC,yQACJL,+PAJgBK,mIAAZC,8bChFmD,6uCCfvD,MAAIC,UAIJ,kaAYM,SAAAC,+4BAOyCC,swBA3B/ClB,EAAAmB,EAAAC,KAAAZ,yUCsCM,uxBAIMA"}