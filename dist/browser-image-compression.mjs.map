{"version":3,"file":"browser-image-compression.mjs","sources":["../lib/utils.js","../lib/image-compression.js","../lib/web-worker.js","../lib/index.js"],"sourcesContent":["// add support for cordova-plugin-file\r\nconst moduleMapper = typeof window !== 'undefined' && window.cordova && window.cordova.require('cordova/modulemapper');\r\nexport const CustomFile = (moduleMapper && moduleMapper.getOriginalSymbol(window, 'File')) || File;\r\nexport const CustomFileReader = (moduleMapper && moduleMapper.getOriginalSymbol(window, 'FileReader')) || FileReader;\r\n/**\r\n * getDataUrlFromFile\r\n *\r\n * @param {File} file\r\n * @returns {Promise<string>}\r\n */\r\nexport function getDataUrlFromFile (file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new CustomFileReader()\r\n    reader.onload = () => resolve(reader.result)\r\n    reader.onerror = (e) => reject(e)\r\n    reader.readAsDataURL(file)\r\n  })\r\n}\r\n\r\n/**\r\n * getFilefromDataUrl\r\n *\r\n * @param {string} dataurl\r\n * @param {string} filename\r\n * @param {number} [lastModified=Date.now()]\r\n * @returns {Promise<File|Blob>}\r\n */\r\nexport function getFilefromDataUrl (dataurl, filename, lastModified = Date.now()) {\r\n  return new Promise((resolve) => {\r\n    const arr = dataurl.split(',')\r\n    const mime = arr[0].match(/:(.*?);/)[1]\r\n    const bstr = atob(arr[1])\r\n    let n = bstr.length\r\n    const u8arr = new Uint8Array(n)\r\n    while (n--) {\r\n      u8arr[n] = bstr.charCodeAt(n)\r\n    }\r\n    const file = new Blob([u8arr], { type: mime })\r\n    file.name = filename\r\n    file.lastModified = lastModified\r\n    resolve(file)\r\n\r\n    // Safari has issue with File constructor not being able to POST in FormData\r\n    // https://github.com/Donaldcwl/browser-image-compression/issues/8\r\n    // https://bugs.webkit.org/show_bug.cgi?id=165081\r\n    // let file\r\n    // try {\r\n    //   file = new File([u8arr], filename, { type: mime }) // Edge do not support File constructor\r\n    // } catch (e) {\r\n    //   file = new Blob([u8arr], { type: mime })\r\n    //   file.name = filename\r\n    //   file.lastModified = lastModified\r\n    // }\r\n    // resolve(file)\r\n  })\r\n}\r\n\r\n/**\r\n * loadImage\r\n *\r\n * @param {string} src\r\n * @returns {Promise<HTMLImageElement>}\r\n */\r\nexport function loadImage (src) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image()\r\n    img.onload = () => resolve(img)\r\n    img.onerror = (e) => reject(e)\r\n    img.src = src\r\n  })\r\n}\r\n\r\n/**\r\n * drawImageInCanvas\r\n *\r\n * @param {HTMLImageElement} img\r\n * @returns {HTMLCanvasElement}\r\n */\r\nexport function drawImageInCanvas (img) {\r\n  const [canvas, ctx] = getNewCanvasAndCtx(img.width, img.height)\r\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\r\n  return canvas\r\n}\r\n\r\n/**\r\n * drawFileInCanvas\r\n *\r\n * @param {File} file\r\n * @returns {Promise<[ImageBitmap | HTMLImageElement, HTMLCanvasElement]>}\r\n */\r\nexport async function drawFileInCanvas (file) {\r\n  let img\r\n  try {\r\n    img = await createImageBitmap(file)\r\n  } catch (e) {\r\n    const dataUrl = await getDataUrlFromFile(file)\r\n    img = await loadImage(dataUrl)\r\n  }\r\n  const canvas = drawImageInCanvas(img)\r\n  return [img, canvas]\r\n}\r\n\r\n/**\r\n * canvasToFile\r\n *\r\n * @param canvas\r\n * @param {string} fileType\r\n * @param {string} fileName\r\n * @param {number} fileLastModified\r\n * @param {number} [quality]\r\n * @returns {Promise<File|Blob>}\r\n */\r\nexport async function canvasToFile (canvas, fileType, fileName, fileLastModified, quality = 1) {\r\n  let file\r\n  if (typeof OffscreenCanvas === 'function' && canvas instanceof OffscreenCanvas) {\r\n    file = await canvas.convertToBlob({ type: fileType, quality })\r\n    file.name = fileName\r\n    file.lastModified = fileLastModified\r\n  } else {\r\n    const dataUrl = canvas.toDataURL(fileType, quality)\r\n    file = await getFilefromDataUrl(dataUrl, fileName, fileLastModified)\r\n  }\r\n  return file\r\n}\r\n\r\n/**\r\n * getExifOrientation\r\n * get image exif orientation info\r\n * source: https://stackoverflow.com/a/32490603/10395024\r\n *\r\n * @param {File} file\r\n * @returns {Promise<number>} - orientation id, see https://i.stack.imgur.com/VGsAj.gif\r\n */\r\nexport function getExifOrientation (file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new CustomFileReader()\r\n    reader.onload = (e) => {\r\n      const view = new DataView(e.target.result)\r\n      if (view.getUint16(0, false) != 0xFFD8) {\r\n        return resolve(-2)\r\n      }\r\n      const length = view.byteLength\r\n      let offset = 2\r\n      while (offset < length) {\r\n        if (view.getUint16(offset + 2, false) <= 8) return resolve(-1)\r\n        const marker = view.getUint16(offset, false)\r\n        offset += 2\r\n        if (marker == 0xFFE1) {\r\n          if (view.getUint32(offset += 2, false) != 0x45786966) {\r\n            return resolve(-1)\r\n          }\r\n\r\n          var little = view.getUint16(offset += 6, false) == 0x4949\r\n          offset += view.getUint32(offset + 4, little)\r\n          var tags = view.getUint16(offset, little)\r\n          offset += 2\r\n          for (var i = 0; i < tags; i++) {\r\n            if (view.getUint16(offset + (i * 12), little) == 0x0112) {\r\n              return resolve(view.getUint16(offset + (i * 12) + 8, little))\r\n            }\r\n          }\r\n        } else if ((marker & 0xFF00) != 0xFF00) {\r\n          break\r\n        } else {\r\n          offset += view.getUint16(offset, false)\r\n        }\r\n      }\r\n      return resolve(-1)\r\n    }\r\n    reader.onerror = (e) => reject(e)\r\n    reader.readAsArrayBuffer(file)\r\n  })\r\n}\r\n\r\n/**\r\n *\r\n * @param {HTMLCanvasElement} canvas\r\n * @param options\r\n * @returns {HTMLCanvasElement>}\r\n */\r\nexport function handleMaxWidthOrHeight (canvas, options) {\r\n  const width = canvas.width\r\n  const height = canvas.height\r\n  const maxWidthOrHeight = options.maxWidthOrHeight\r\n\r\n  const needToHandle = Number.isInteger(maxWidthOrHeight) && (width > maxWidthOrHeight || height > maxWidthOrHeight)\r\n\r\n  let newCanvas = canvas\r\n  let ctx\r\n\r\n  if (needToHandle) {\r\n    [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\r\n    if (width > height) {\r\n      newCanvas.width = maxWidthOrHeight\r\n      newCanvas.height = (height / width) * maxWidthOrHeight\r\n    } else {\r\n      newCanvas.width = (width / height) * maxWidthOrHeight\r\n      newCanvas.height = maxWidthOrHeight\r\n    }\r\n    ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height)\r\n  }\r\n\r\n  return newCanvas\r\n}\r\n\r\n/**\r\n * followExifOrientation\r\n * source: https://stackoverflow.com/a/40867559/10395024\r\n *\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {number} exifOrientation\r\n * @returns {HTMLCanvasElement} canvas\r\n */\r\nexport function followExifOrientation (canvas, exifOrientation) {\r\n  const width = canvas.width\r\n  const height = canvas.height\r\n\r\n  const [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\r\n\r\n  // set proper canvas dimensions before transform & export\r\n  if (4 < exifOrientation && exifOrientation < 9) {\r\n    newCanvas.width = height\r\n    newCanvas.height = width\r\n  } else {\r\n    newCanvas.width = width\r\n    newCanvas.height = height\r\n  }\r\n\r\n  // transform context before drawing image\r\n  switch (exifOrientation) {\r\n    case 2: ctx.transform(-1, 0, 0, 1, width, 0); break;\r\n    case 3: ctx.transform(-1, 0, 0, -1, width, height); break;\r\n    case 4: ctx.transform(1, 0, 0, -1, 0, height); break;\r\n    case 5: ctx.transform(0, 1, 1, 0, 0, 0); break;\r\n    case 6: ctx.transform(0, 1, -1, 0, height, 0); break;\r\n    case 7: ctx.transform(0, -1, -1, 0, height, width); break;\r\n    case 8: ctx.transform(0, -1, 1, 0, 0, width); break;\r\n    default: break;\r\n  }\r\n\r\n  ctx.drawImage(canvas, 0, 0, width, height)\r\n\r\n  return newCanvas\r\n}\r\n\r\n/**\r\n * get new Canvas and it's context\r\n * @param width\r\n * @param height\r\n * @returns {[HTMLCanvasElement, CanvasRenderingContext2D]}\r\n */\r\nexport function getNewCanvasAndCtx (width, height) {\r\n  let canvas\r\n  let ctx\r\n  try {\r\n    canvas = new OffscreenCanvas(width, height)\r\n    ctx = canvas.getContext('2d')\r\n  } catch (e) {\r\n    canvas = document.createElement('canvas')\r\n    ctx = canvas.getContext('2d')\r\n  }\r\n  canvas.width = width\r\n  canvas.height = height\r\n  return [canvas, ctx]\r\n}\r\n\r\nNumber.isInteger = Number.isInteger || function(value) {\r\n  return typeof value === 'number' && \r\n    isFinite(value) && \r\n    Math.floor(value) === value;\r\n}\r\n","import { canvasToFile, drawFileInCanvas, followExifOrientation, getExifOrientation, handleMaxWidthOrHeight, getNewCanvasAndCtx } from './utils'\r\n\r\n/**\r\n * Compress an image file.\r\n *\r\n * @param {File} file\r\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=true, maxIteration = 10, exifOrientation }\r\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\r\n * @param {number} [options.maxWidthOrHeight=undefined] * @param {number} [options.maxWidthOrHeight=undefined]\r\n * @param {number} [options.maxIteration=10]\r\n * @param {number} [options.exifOrientation=] - default to be the exif orientation from the image file\r\n * @returns {Promise<File | Blob>}\r\n */\r\nexport default async function compress (file, options) {\r\n  let remainingTrials = options.maxIteration || 10\r\n\r\n  const maxSizeByte = options.maxSizeMB * 1024 * 1024\r\n\r\n  // drawFileInCanvas\r\n  let [img, canvas] = await drawFileInCanvas(file)\r\n\r\n  // handleMaxWidthOrHeight\r\n  canvas = handleMaxWidthOrHeight(canvas, options)\r\n\r\n  // exifOrientation\r\n  options.exifOrientation = options.exifOrientation || await getExifOrientation(file)\r\n  canvas = followExifOrientation(canvas, options.exifOrientation)\r\n\r\n  let quality = 1\r\n\r\n  let tempFile = await canvasToFile(canvas, file.type, file.name, file.lastModified, quality)\r\n  // check if we need to compress or resize\r\n  if (tempFile.size <= maxSizeByte) {\r\n    // no need to compress\r\n    return tempFile\r\n  }\r\n\r\n  let compressedFile = tempFile\r\n  while (remainingTrials-- && compressedFile.size > maxSizeByte) {\r\n    const newWidth = canvas.width * 0.9\r\n    const newHeight = canvas.height * 0.9\r\n    const [newCanvas, ctx] = getNewCanvasAndCtx(newWidth, newHeight)\r\n\r\n    ctx.drawImage(canvas, 0, 0, newWidth, newHeight)\r\n\r\n    if (file.type === 'image/jpeg') {\r\n      quality *= 0.9\r\n    }\r\n    compressedFile = await canvasToFile(newCanvas, file.type, file.name, file.lastModified, quality)\r\n\r\n    canvas = newCanvas\r\n  }\r\n\r\n  return compressedFile\r\n}","import imageCompression from './index'\r\nimport compress from './image-compression'\r\nimport { getNewCanvasAndCtx } from './utils'\r\n\r\nlet cnt = 0\r\nlet imageCompressionLibUrl\r\n\r\nfunction createWorker (f) {\r\n  return new Worker(URL.createObjectURL(new Blob([`(${f})()`])))\r\n}\r\n\r\nconst worker = createWorker(() => {\r\n  let scriptImported = false\r\n  self.addEventListener('message', async (e) => {\r\n    const { file, id, imageCompressionLibUrl, options } = e.data\r\n    try {\r\n      if (!scriptImported) {\r\n        // console.log('[worker] importScripts', imageCompressionLibUrl)\r\n        importScripts(imageCompressionLibUrl)\r\n        scriptImported = true\r\n      }\r\n      // console.log('[worker] self', self)\r\n      const compressedFile = await imageCompression(file, options)\r\n      self.postMessage({ file: compressedFile, id })\r\n    } catch (e) {\r\n      // console.error('[worker] error', e)\r\n      self.postMessage({ error: e.message + '\\n' + e.stack, id })\r\n    }\r\n  })\r\n})\r\n\r\nfunction createSourceObject (str) {\r\n  return URL.createObjectURL(new Blob([str], { type: 'application/javascript' }))\r\n}\r\n\r\nexport function compressOnWebWorker (file, options) {\r\n  return new Promise(async (resolve, reject) => {\r\n    if (!imageCompressionLibUrl) {\r\n      imageCompressionLibUrl = createSourceObject(`\r\n    function imageCompression (){return (${imageCompression}).apply(null, arguments)}\r\n\r\n    imageCompression.getDataUrlFromFile = ${imageCompression.getDataUrlFromFile}\r\n    imageCompression.getFilefromDataUrl = ${imageCompression.getFilefromDataUrl}\r\n    imageCompression.loadImage = ${imageCompression.loadImage}\r\n    imageCompression.drawImageInCanvas = ${imageCompression.drawImageInCanvas}\r\n    imageCompression.drawFileInCanvas = ${imageCompression.drawFileInCanvas}\r\n    imageCompression.canvasToFile = ${imageCompression.canvasToFile}\r\n    imageCompression.getExifOrientation = ${imageCompression.getExifOrientation}\r\n    imageCompression.handleMaxWidthOrHeight = ${imageCompression.handleMaxWidthOrHeight}\r\n    imageCompression.followExifOrientation = ${imageCompression.followExifOrientation}\r\n\r\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\r\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\r\n    loadImage = imageCompression.loadImage\r\n    drawImageInCanvas = imageCompression.drawImageInCanvas\r\n    drawFileInCanvas = imageCompression.drawFileInCanvas\r\n    canvasToFile = imageCompression.canvasToFile\r\n    getExifOrientation = imageCompression.getExifOrientation\r\n    handleMaxWidthOrHeight = imageCompression.handleMaxWidthOrHeight\r\n    followExifOrientation = imageCompression.followExifOrientation\r\n\r\n    getNewCanvasAndCtx = ${getNewCanvasAndCtx}\r\n    \r\n    CustomFileReader = FileReader\r\n    \r\n    CustomFile = File\r\n    \r\n    function _slicedToArray(arr, n) { return arr }\r\n\r\n    function compress (){return (${compress}).apply(null, arguments)}\r\n    `)\r\n    }\r\n    let id = cnt++\r\n\r\n    function handler (e) {\r\n      if (e.data.id === id) {\r\n        worker.removeEventListener('message', handler)\r\n        if (e.data.error) {\r\n          reject(new Error(e.data.error))\r\n        }\r\n        resolve(e.data.file)\r\n      }\r\n    }\r\n\r\n    worker.addEventListener('message', handler)\r\n    worker.postMessage({ file, id, imageCompressionLibUrl, options })\r\n  })\r\n}","import compress from './image-compression'\r\nimport {\r\n  canvasToFile,\r\n  drawFileInCanvas,\r\n  drawImageInCanvas,\r\n  getDataUrlFromFile,\r\n  getFilefromDataUrl,\r\n  loadImage,\r\n  getExifOrientation,\r\n  handleMaxWidthOrHeight,\r\n  followExifOrientation,\r\n  CustomFile\r\n} from './utils'\r\nimport { compressOnWebWorker } from './web-worker'\r\n\r\n/**\r\n * Compress an image file.\r\n *\r\n * @param {File} file\r\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=true, maxIteration = 10, exifOrientation }\r\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\r\n * @param {number} [options.maxWidthOrHeight=undefined] * @param {number} [options.maxWidthOrHeight=undefined]\r\n * @param {boolean} [options.useWebWorker=true]\r\n * @param {number} [options.maxIteration=10]\r\n * @param {number} [options.exifOrientation=] - default to be the exif orientation from the image file\r\n * @returns {Promise<File | Blob>}\r\n */\r\nasync function imageCompression (file, options) {\r\n\r\n  let compressedFile\r\n\r\n  options.maxSizeMB = options.maxSizeMB || Number.POSITIVE_INFINITY\r\n  options.useWebWorker = typeof options.useWebWorker === 'boolean' ? options.useWebWorker : true\r\n\r\n  if (!(file instanceof Blob || file instanceof CustomFile)) {\r\n    throw new Error('The file given is not an instance of Blob or File')\r\n  } else if (!/^image/.test(file.type)) {\r\n    throw new Error('The file given is not an image')\r\n  }\r\n\r\n  // try run in web worker, fall back to run in main thread\r\n  const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\r\n\r\n  // if (inWebWorker) {\r\n  //   console.log('run compression in web worker')\r\n  // } else {\r\n  //   console.log('run compression in main thread')\r\n  // }\r\n\r\n  if (options.useWebWorker && typeof Worker === 'function' && !inWebWorker) {\r\n    try {\r\n      // \"compressOnWebWorker\" is kind of like a recursion to call \"imageCompression\" again inside web worker\r\n      compressedFile = await compressOnWebWorker(file, options)\r\n    } catch (e) {\r\n      console.warn('Run compression in web worker failed:', e, ', fall back to main thread')\r\n      compressedFile = await compress(file, options)\r\n    }\r\n  } else {\r\n    compressedFile = await compress(file, options)\r\n  }\r\n\r\n  try {\r\n    compressedFile.name = file.name\r\n    compressedFile.lastModified = file.lastModified\r\n  } catch (e) {}\r\n\r\n  return compressedFile\r\n}\r\n\r\nimageCompression.getDataUrlFromFile = getDataUrlFromFile\r\nimageCompression.getFilefromDataUrl = getFilefromDataUrl\r\nimageCompression.loadImage = loadImage\r\nimageCompression.drawImageInCanvas = drawImageInCanvas\r\nimageCompression.drawFileInCanvas = drawFileInCanvas\r\nimageCompression.canvasToFile = canvasToFile\r\nimageCompression.getExifOrientation = getExifOrientation\r\nimageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight\r\nimageCompression.followExifOrientation = followExifOrientation\r\n\r\nexport default imageCompression\r\n"],"names":["window","cordova","require","CustomFile","reader","onload","reject","file","getFilefromDataUrl","n","loadImage","fileType","view","result","length","offset","getUint32","marker","readAsArrayBuffer","width","height","canvas","options","ctx","maxWidthOrHeight","followExifOrientation","lastModified","cnt","compressOnWebWorker","imageCompression","name","drawImageInCanvas","drawFileInCanvas","canvasToFile","getExifOrientation","handleMaxWidthOrHeight"],"mappings":";;;;;;;sdAEA,kCAA2CA,gBAAAA,OAAAC,QAAAC,gCAC9BC,2NAyBXC,EAAAC,OAAA,oBAAgCD,wCACVE,sBACHC,cAUTC,0LAuBe,mCAGvBC,wnBA8CkBC,qcAOF,MAAAC,gZAmBdC,wBAAIC,yDAIJC,iBACO,uBAC8CC,EAAS,2CAC9B,oBAEhB,IACoB,wBAAvBA,GAAU,wDAMnBH,EAAAI,UAAWD,iCAEX,4GAMAE,gFASVb,EAAAc,kEAoBIC,IAAAA,MACAC,EAAIC,WACFC,kHASJC,mCAW6CC,YAE9BL,8BAMHE,EAAQ,wCAWNI,sBAAuBJ,mBACnCD,kKAOiCD,mQAiBvBE,sxBCvOmBd,SAAgBmB,kIAW3C,0HAQgBnB,2jBCxCtB,MAAIoB,UAIJ,uoBASQC,yrBAmEeC,u+ECtBJC,mHAMnBD,iBAAArB,mBAAsCA,mBACtCqB,iBAAAnB,oBACAmB,iBAAAE,oCACAF,iBAAAG,iBAAAA,iBACAH,iBAAAI,0BACAJ,iBAAAK,sCACAL,iBAAAM,8CACAN,iBAAAJ,sBAAAA"}
